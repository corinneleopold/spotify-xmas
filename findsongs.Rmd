---
title: "Creating the Best Christmas Playlists"
output: html_notebook
---

This program finds the most popular, non-traditional versions of Christmas songs.

See the most popular songs by categories including:

- Genre
- Instrument only
- Danceability
- Acousticness
- Tempo

This can be used to create a mixed playlist or individual playlists by category.

### Install the spotifyr and curlconverter packages
```{r}
#devtools::install_github("charlie86/spotifyr")
#devtools::install_github("hrbrmstr/curlconverter")
```

```{r}
library(spotifyr)
library(curlconverter)
library(plyr)
library(dplyr)
library(jsonlite)
```

### Set Spotify credentials

```{r}
#Sys.setenv(SPOTIFY_CLIENT_ID = "your client id")
#Sys.setenv(SPOTIFY_CLIENT_SECRET = "your client secret")
```

### Search for playlists that contain a term/phrase
The `searchPlaylists` function performs a GET request that searches for Spotify playlists for a given query.

It returns a data frame with all playlist results.
```{r}
searchPlaylists <- function(query, token) {
  # format query
  queryUrl <- paste("'https://api.spotify.com/v1/search?q=%22", URLencode(query), "%22&type=playlist'", 
                    sep="")
  # format authorization
  authToken <- paste("'Authorization: Bearer ", token, "'", sep="")
  
  # format and make request
  req <- paste("curl -X GET ", 
               queryUrl, 
               " -H 'Accept: application/json' -H 'Content-Type: application/json' -H ",
               authToken, 
               sep = "")
  resp <- make_req(straighten(req))

  # Convert result to json
  respJson <- toJSON(content(resp[[1]](), as="parsed"), auto_unbox = TRUE, pretty=TRUE) 
  # Convert json to data frame
  respDf <- fromJSON(respJson)

  # Extract the playlist info we need
  result <- data.frame(playlist_name = respDf$playlists$items$name,
                       playlist_tracks_url = respDf$playlists$items$tracks$href,
                       playlist_num_tracks = respDf$playlists$items$tracks$total,
                       playlist_img = NA, # needed for later
                       playlist_id = respDf$playlists$items$id,
                       external_url = respDf$playlists$items$external_urls$spotify
                       )
  return(result)
}
```


### Since `searchPlaylists` returns many playlists, get the number of followers for each playlist and only keep the playlists with the top n follower counts.
```{r}
# Example: Get top 3 playlists
# getTopPLs(playlistDf, n = 3, get_spotify_access_token())
getTopPLs <- function(df, n = 5, token) {
  
  df$followers <- NA
  i <- 1
  
  # Loop through playlist_id, get each playlist's number of followers, and store result in df
  for (id in df$playlist_id) {
    followReq <- paste("curl -X GET 'https://api.spotify.com/v1/playlists/", id, 
                       "' -H 'Authorization: Bearer ", token, "'", sep="")
    followResp <- make_req(straighten(followReq))
  
    # Convert result to json
    followJson <- toJSON(content(followResp[[1]](), as="parsed"), auto_unbox = TRUE, pretty=TRUE)
    # Convert json to data frame
    followDf <- fromJSON(followJson)

    # Set corresponding value in followers column
    df$followers[i] <- followDf$followers$total
    i <- i + 1
  }
  
  return(df %>% 
           top_n(n, followers) %>% 
           arrange(desc(followers)))
}
```


### Get track popularity

```{r}
getPop <- function(topPLs) {
  # Extract the unique tracks
  tracks <-  get_playlist_tracks(topPLs) %>% 
    distinct(track_name, artist_name, .keep_all = TRUE)
  
  # Get popularity
  trackPop <- get_track_popularity(tracks) %>% 
    arrange(desc(track_popularity)) 

  # Join popularity df w/ track df, and select cols we want
  fullTrackDf <- join(trackPop, tracks, type = "full", by = "track_uri")
  fullTrackDf <- fullTrackDf %>% 
    select(track_name, track_popularity, track_uri, playlist_name, artist_name, track_open_spotify_url)

  return(fullTrackDf)
}
```

### Clean up data frame
- Remove low popularity tracks
- Only keep 1 version of each track name
- Balance the number of tracks per artist

```{r}
# lowPop: only keep songs whose popularity is higher than this value (default 30)
cleanup <- function(fullTrackDf, lowPop = 30) {
  # Remove low popularity tracks
  fullTrackDf <- fullTrackDf %>%
    filter(track_popularity > lowPop)

  # If multiple tracks with the same name, keep the one w/ highest popularity
  fullTrackDfFilt <- fullTrackDf %>%
    group_by(track_name) %>% 
    arrange(desc(track_popularity)) %>%
    top_n(1, track_popularity)

  # For every artist, only keep their top 4 songs (or more if tied)
  fullTrackDfFilt <- fullTrackDfFilt %>% 
    group_by(artist_name) %>% 
    top_n(4, track_popularity)

  return(fullTrackDfFilt)
}
```


### Run all functions
Returns a final data frame for a given query

```{r}
createPlaylist <- function(query) {
  # Get all playlists matching search term
  playlists <- searchPlaylists(query, get_spotify_access_token())
  
  # Filter by playlists with most followers
  topPlaylists <- getTopPLs(playlists, n = 5, get_spotify_access_token())
  
  trackDf <- getPop(topPlaylists)
  trackDf <- cleanup(trackDf, lowPop = 30) 
  
  return(trackDf)
}
```


```{r}
# Instrumental songs
instrumental <- createPlaylist("Christmas instrumental")

# A Cappella songs
acappella <- createPlaylist("a cappella christmas")
head(acappella)
```





### Get audio features
```{r}
get_track_audio_features(fullTrackDf %>% select(track_name, track_uri) %>% slice(1))
```





